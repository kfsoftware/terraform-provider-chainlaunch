// Code generated by go-swagger; DO NOT EDIT.

package chaincode

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new chaincode API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new chaincode API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new chaincode API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for chaincode API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptTextEventStream sets the Accept header to "text/event-stream".
func WithAcceptTextEventStream(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/event-stream"}
}

// WithAcceptTextPlain sets the Accept header to "text/plain".
func WithAcceptTextPlain(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/plain"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	AcceptChaincodeProposal(params *AcceptChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptChaincodeProposalOK, error)

	ApproveChaincodeByDefinition(params *ApproveChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveChaincodeByDefinitionOK, error)

	CommitChaincodeByDefinition(params *CommitChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CommitChaincodeByDefinitionOK, error)

	CreateChaincode(params *CreateChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateChaincodeOK, error)

	CreateChaincodeDefinition(params *CreateChaincodeDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateChaincodeDefinitionOK, error)

	CreateChaincodeProposal(params *CreateChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateChaincodeProposalCreated, error)

	DeleteChaincode(params *DeleteChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteChaincodeOK, error)

	DeleteChaincodeDefinition(params *DeleteChaincodeDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteChaincodeDefinitionOK, error)

	DeployChaincodeByDefinition(params *DeployChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeployChaincodeByDefinitionOK, error)

	GetChaincodeDefinitionDetail(params *GetChaincodeDefinitionDetailParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionDetailOK, error)

	GetChaincodeDefinitionDockerInfo(params *GetChaincodeDefinitionDockerInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionDockerInfoOK, error)

	GetChaincodeDefinitionLogs(params *GetChaincodeDefinitionLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionLogsOK, error)

	GetChaincodeDefinitionTimeline(params *GetChaincodeDefinitionTimelineParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionTimelineOK, error)

	GetChaincodeMetadata(params *GetChaincodeMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeMetadataOK, error)

	GetChaincodeProposal(params *GetChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeProposalOK, error)

	InstallChaincodeByDefinition(params *InstallChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallChaincodeByDefinitionOK, error)

	InvokeChaincode(params *InvokeChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvokeChaincodeOK, error)

	ListChaincodeDefinitions(params *ListChaincodeDefinitionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListChaincodeDefinitionsOK, error)

	ListChaincodeProposals(params *ListChaincodeProposalsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListChaincodeProposalsOK, error)

	QueryChaincode(params *QueryChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QueryChaincodeOK, error)

	RemoveChaincodeDeployment(params *RemoveChaincodeDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveChaincodeDeploymentOK, error)

	ShareChaincodeProposal(params *ShareChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareChaincodeProposalOK, error)

	UpdateChaincodeDefinition(params *UpdateChaincodeDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChaincodeDefinitionOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AcceptChaincodeProposal accepts a chaincode proposal

Accept a chaincode proposal, create the chaincode and definition if needed, and return the full structure
*/
func (a *Client) AcceptChaincodeProposal(params *AcceptChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptChaincodeProposalOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewAcceptChaincodeProposalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "acceptChaincodeProposal",
		Method:             "POST",
		PathPattern:        "/pro/chaincodes/proposals/{proposalId}/accept",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AcceptChaincodeProposalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*AcceptChaincodeProposalOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for acceptChaincodeProposal: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ApproveChaincodeByDefinition approves chaincode based on chaincode definition

Approve chaincode for a given definition
*/
func (a *Client) ApproveChaincodeByDefinition(params *ApproveChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ApproveChaincodeByDefinitionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewApproveChaincodeByDefinitionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "approveChaincodeByDefinition",
		Method:             "POST",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/approve",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ApproveChaincodeByDefinitionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ApproveChaincodeByDefinitionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for approveChaincodeByDefinition: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CommitChaincodeByDefinition commits chaincode based on chaincode definition

Commit chaincode for a given definition
*/
func (a *Client) CommitChaincodeByDefinition(params *CommitChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CommitChaincodeByDefinitionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCommitChaincodeByDefinitionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "commitChaincodeByDefinition",
		Method:             "POST",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/commit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CommitChaincodeByDefinitionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CommitChaincodeByDefinitionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for commitChaincodeByDefinition: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateChaincode creates a chaincode

Create a new chaincode
*/
func (a *Client) CreateChaincode(params *CreateChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateChaincodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateChaincodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createChaincode",
		Method:             "POST",
		PathPattern:        "/sc/fabric/chaincodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateChaincodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CreateChaincodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createChaincode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateChaincodeDefinition creates a chaincode definition

Create a new chaincode definition for a chaincode
*/
func (a *Client) CreateChaincodeDefinition(params *CreateChaincodeDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateChaincodeDefinitionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateChaincodeDefinitionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createChaincodeDefinition",
		Method:             "POST",
		PathPattern:        "/sc/fabric/chaincodes/{chaincodeId}/definitions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateChaincodeDefinitionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CreateChaincodeDefinitionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createChaincodeDefinition: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateChaincodeProposal creates a new chaincode proposal

Create a new chaincode proposal
*/
func (a *Client) CreateChaincodeProposal(params *CreateChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateChaincodeProposalCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateChaincodeProposalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createChaincodeProposal",
		Method:             "POST",
		PathPattern:        "/pro/chaincodes/proposals",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateChaincodeProposalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CreateChaincodeProposalCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createChaincodeProposal: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteChaincode deletes a chaincode

Delete a chaincode and all its definitions
*/
func (a *Client) DeleteChaincode(params *DeleteChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteChaincodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteChaincodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteChaincode",
		Method:             "DELETE",
		PathPattern:        "/sc/fabric/chaincodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteChaincodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeleteChaincodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteChaincode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteChaincodeDefinition deletes a chaincode definition

Delete a chaincode definition by ID
*/
func (a *Client) DeleteChaincodeDefinition(params *DeleteChaincodeDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteChaincodeDefinitionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteChaincodeDefinitionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteChaincodeDefinition",
		Method:             "DELETE",
		PathPattern:        "/sc/fabric/definitions/{definitionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteChaincodeDefinitionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeleteChaincodeDefinitionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteChaincodeDefinition: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeployChaincodeByDefinition deploys chaincode based on chaincode definition docker

Deploy chaincode for a given definition using Docker image
*/
func (a *Client) DeployChaincodeByDefinition(params *DeployChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeployChaincodeByDefinitionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeployChaincodeByDefinitionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deployChaincodeByDefinition",
		Method:             "POST",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/deploy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeployChaincodeByDefinitionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeployChaincodeByDefinitionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deployChaincodeByDefinition: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetChaincodeDefinitionDetail gets chaincode definition details by ID

Get detailed information about a specific chaincode definition including its events
*/
func (a *Client) GetChaincodeDefinitionDetail(params *GetChaincodeDefinitionDetailParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionDetailOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaincodeDefinitionDetailParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaincodeDefinitionDetail",
		Method:             "GET",
		PathPattern:        "/sc/fabric/chaincodes/{chaincodeId}/definitions/{definitionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaincodeDefinitionDetailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaincodeDefinitionDetailOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaincodeDefinitionDetail: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetChaincodeDefinitionDockerInfo gets docker info for a chaincode definition

Get Docker container info for a specific chaincode definition by ID
*/
func (a *Client) GetChaincodeDefinitionDockerInfo(params *GetChaincodeDefinitionDockerInfoParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionDockerInfoOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaincodeDefinitionDockerInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaincodeDefinitionDockerInfo",
		Method:             "GET",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/docker-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaincodeDefinitionDockerInfoReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaincodeDefinitionDockerInfoOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaincodeDefinitionDockerInfo: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetChaincodeDefinitionLogs gets chaincode container logs

Get logs from a chaincode container by definition ID. When follow=true, streams logs in real-time using Server-Sent Events. When follow=false, returns all logs directly as plain text.
*/
func (a *Client) GetChaincodeDefinitionLogs(params *GetChaincodeDefinitionLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionLogsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaincodeDefinitionLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaincodeDefinitionLogs",
		Method:             "GET",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/logs",
		ProducesMediaTypes: []string{"text/event-stream", "text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaincodeDefinitionLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaincodeDefinitionLogsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaincodeDefinitionLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetChaincodeDefinitionTimeline gets timeline of events for a chaincode definition

Get the timeline of install/approve/commit/deploy events for a chaincode definition
*/
func (a *Client) GetChaincodeDefinitionTimeline(params *GetChaincodeDefinitionTimelineParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeDefinitionTimelineOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaincodeDefinitionTimelineParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaincodeDefinitionTimeline",
		Method:             "GET",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/timeline",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaincodeDefinitionTimelineReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaincodeDefinitionTimelineOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaincodeDefinitionTimeline: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetChaincodeMetadata gets chaincode metadata

Get metadata for a specific chaincode by executing org.hyperledger.fabric:GetMetadata
*/
func (a *Client) GetChaincodeMetadata(params *GetChaincodeMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeMetadataOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaincodeMetadataParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaincodeMetadata",
		Method:             "GET",
		PathPattern:        "/sc/fabric/chaincodes/{chaincodeId}/metadata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaincodeMetadataReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaincodeMetadataOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaincodeMetadata: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetChaincodeProposal gets a chaincode proposal

Get details of a specific chaincode proposal, including its definition and chaincode if accepted
*/
func (a *Client) GetChaincodeProposal(params *GetChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeProposalOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaincodeProposalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaincodeProposal",
		Method:             "GET",
		PathPattern:        "/pro/chaincodes/proposals/{proposalId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaincodeProposalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaincodeProposalOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaincodeProposal: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InstallChaincodeByDefinition installs chaincode based on chaincode definition

Install chaincode on peers for a given definition
*/
func (a *Client) InstallChaincodeByDefinition(params *InstallChaincodeByDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InstallChaincodeByDefinitionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewInstallChaincodeByDefinitionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "installChaincodeByDefinition",
		Method:             "POST",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/install",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InstallChaincodeByDefinitionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*InstallChaincodeByDefinitionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for installChaincodeByDefinition: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InvokeChaincode invokes a chaincode

Invoke a transaction on a specific chaincode
*/
func (a *Client) InvokeChaincode(params *InvokeChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvokeChaincodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewInvokeChaincodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "invokeChaincode",
		Method:             "POST",
		PathPattern:        "/sc/fabric/chaincodes/{chaincodeId}/invoke",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvokeChaincodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*InvokeChaincodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for invokeChaincode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListChaincodeDefinitions lists chaincode definitions for a chaincode

List all definitions for a given chaincode
*/
func (a *Client) ListChaincodeDefinitions(params *ListChaincodeDefinitionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListChaincodeDefinitionsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListChaincodeDefinitionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listChaincodeDefinitions",
		Method:             "GET",
		PathPattern:        "/sc/fabric/chaincodes/{chaincodeId}/definitions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListChaincodeDefinitionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListChaincodeDefinitionsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listChaincodeDefinitions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListChaincodeProposals lists chaincode proposals

List all chaincode proposals, optionally filtered by network ID
*/
func (a *Client) ListChaincodeProposals(params *ListChaincodeProposalsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListChaincodeProposalsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListChaincodeProposalsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listChaincodeProposals",
		Method:             "GET",
		PathPattern:        "/pro/chaincodes/proposals",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListChaincodeProposalsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListChaincodeProposalsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listChaincodeProposals: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
QueryChaincode queries a chaincode

Query a specific chaincode
*/
func (a *Client) QueryChaincode(params *QueryChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QueryChaincodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewQueryChaincodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "queryChaincode",
		Method:             "POST",
		PathPattern:        "/sc/fabric/chaincodes/{chaincodeId}/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &QueryChaincodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*QueryChaincodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for queryChaincode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RemoveChaincodeDeployment removes deployment for a chaincode definition

Remove the deployment (e.g., Docker container) for a given chaincode definition
*/
func (a *Client) RemoveChaincodeDeployment(params *RemoveChaincodeDeploymentParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveChaincodeDeploymentOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRemoveChaincodeDeploymentParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "removeChaincodeDeployment",
		Method:             "POST",
		PathPattern:        "/sc/fabric/definitions/{definitionId}/undeploy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RemoveChaincodeDeploymentReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RemoveChaincodeDeploymentOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for removeChaincodeDeployment: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ShareChaincodeProposal shares a chaincode proposal with recipients

Share a chaincode proposal with specified connection IDs
*/
func (a *Client) ShareChaincodeProposal(params *ShareChaincodeProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareChaincodeProposalOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewShareChaincodeProposalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shareChaincodeProposal",
		Method:             "POST",
		PathPattern:        "/pro/chaincodes/proposals/{proposalId}/share",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShareChaincodeProposalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ShareChaincodeProposalOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for shareChaincodeProposal: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateChaincodeDefinition updates a chaincode definition

Update an existing chaincode definition by ID
*/
func (a *Client) UpdateChaincodeDefinition(params *UpdateChaincodeDefinitionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateChaincodeDefinitionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateChaincodeDefinitionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateChaincodeDefinition",
		Method:             "PUT",
		PathPattern:        "/sc/fabric/definitions/{definitionId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateChaincodeDefinitionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*UpdateChaincodeDefinitionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateChaincodeDefinition: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
