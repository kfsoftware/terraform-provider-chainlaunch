// Code generated by go-swagger; DO NOT EDIT.

package node_sharing

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new node sharing API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new node sharing API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new node sharing API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for node sharing API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithContentType allows the client to force the Content-Type header
// to negotiate a specific Consumer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithContentType(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ConsumesMediaTypes = []string{mime}
	}
}

// WithContentTypeApplicationJSON sets the Content-Type header to "application/json".
func WithContentTypeApplicationJSON(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/json"}
}

// WithContentTypeApplicationxWwwFormUrlencoded sets the Content-Type header to "application/x-www-form-urlencoded".
func WithContentTypeApplicationxWwwFormUrlencoded(r *runtime.ClientOperation) {
	r.ConsumesMediaTypes = []string{"application/x-www-form-urlencoded"}
}

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptTextPlain sets the Accept header to "text/plain".
func WithAcceptTextPlain(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/plain"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	AcceptNodeInvitation(params *AcceptNodeInvitationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptNodeInvitationOK, error)

	CheckMetricsEnabled(params *CheckMetricsEnabledParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CheckMetricsEnabledOK, error)

	ForwardMetrics(params *ForwardMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ForwardMetricsOK, error)

	GenerateNodeInvitation(params *GenerateNodeInvitationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateNodeInvitationOK, error)

	GetExternalNodes(params *GetExternalNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetExternalNodesOK, error)

	GetExternalNodesForConnectedPeer(params *GetExternalNodesForConnectedPeerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetExternalNodesForConnectedPeerOK, error)

	GetNodePublicKeyJWK(params *GetNodePublicKeyJWKParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodePublicKeyJWKOK, error)

	ListConnectedPeers(params *ListConnectedPeersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListConnectedPeersOK, error)

	MetricsFederation(params *MetricsFederationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MetricsFederationOK, error)

	RegisterPeerNode(params *RegisterPeerNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RegisterPeerNodeOK, error)

	RemoveConnectedPeer(params *RemoveConnectedPeerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveConnectedPeerOK, error)

	SyncExternalNodes(params *SyncExternalNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SyncExternalNodesOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AcceptNodeInvitation accepts a node invitation using a j w t

Accepts a node invitation by validating the JWT and establishing the connection
*/
func (a *Client) AcceptNodeInvitation(params *AcceptNodeInvitationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptNodeInvitationOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewAcceptNodeInvitationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "acceptNodeInvitation",
		Method:             "POST",
		PathPattern:        "/node/accept-invitation",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AcceptNodeInvitationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*AcceptNodeInvitationOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for acceptNodeInvitation: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CheckMetricsEnabled checks if node has metrics enabled

Returns whether the node has any nodes with metrics enabled
*/
func (a *Client) CheckMetricsEnabled(params *CheckMetricsEnabledParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CheckMetricsEnabledOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCheckMetricsEnabledParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "checkMetricsEnabled",
		Method:             "POST",
		PathPattern:        "/node/metrics-enabled",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CheckMetricsEnabledReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CheckMetricsEnabledOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for checkMetricsEnabled: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ForwardMetrics forwards metrics to federated prometheus

Forwards metrics to the federated Prometheus instance. Returns 400 if no instance is deployed.
*/
func (a *Client) ForwardMetrics(params *ForwardMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ForwardMetricsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewForwardMetricsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "forwardMetrics",
		Method:             "GET",
		PathPattern:        "/node/forward-metrics",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/x-www-form-urlencoded"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ForwardMetricsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ForwardMetricsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for forwardMetrics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GenerateNodeInvitation generates node invitation

Generate a JWT invitation for node sharing
*/
func (a *Client) GenerateNodeInvitation(params *GenerateNodeInvitationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GenerateNodeInvitationOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGenerateNodeInvitationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "generateNodeInvitation",
		Method:             "POST",
		PathPattern:        "/node/generate-invitation",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GenerateNodeInvitationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GenerateNodeInvitationOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for generateNodeInvitation: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetExternalNodes gets external nodes info

Retrieve external nodes information with authentication
*/
func (a *Client) GetExternalNodes(params *GetExternalNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetExternalNodesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetExternalNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getExternalNodes",
		Method:             "POST",
		PathPattern:        "/node/external-nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetExternalNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetExternalNodesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getExternalNodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetExternalNodesForConnectedPeer gets external nodes for a specific connected peer

Retrieve external nodes information for a specific connected peer
*/
func (a *Client) GetExternalNodesForConnectedPeer(params *GetExternalNodesForConnectedPeerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetExternalNodesForConnectedPeerOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetExternalNodesForConnectedPeerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getExternalNodesForConnectedPeer",
		Method:             "GET",
		PathPattern:        "/node/connected-peers/{peer_id}/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetExternalNodesForConnectedPeerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetExternalNodesForConnectedPeerOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getExternalNodesForConnectedPeer: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodePublicKeyJWK gets node s public key as j w k

Serves the node's public key in JWK (JSON Web Key) format according to RFC 7517
*/
func (a *Client) GetNodePublicKeyJWK(params *GetNodePublicKeyJWKParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodePublicKeyJWKOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodePublicKeyJWKParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodePublicKeyJWK",
		Method:             "GET",
		PathPattern:        "/.well-known/node_jwk.json",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodePublicKeyJWKReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodePublicKeyJWKOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodePublicKeyJWK: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListConnectedPeers lists connected peer nodes

Returns a list of node IDs this node is currently connected with
*/
func (a *Client) ListConnectedPeers(params *ListConnectedPeersParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListConnectedPeersOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListConnectedPeersParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listConnectedPeers",
		Method:             "GET",
		PathPattern:        "/node/connected-peers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListConnectedPeersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListConnectedPeersOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listConnectedPeers: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
MetricsFederation enables disable metrics federation for a peer

Enables or disables metrics federation for a connected peer
*/
func (a *Client) MetricsFederation(params *MetricsFederationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*MetricsFederationOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewMetricsFederationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "metricsFederation",
		Method:             "POST",
		PathPattern:        "/node/metrics-federation",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &MetricsFederationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*MetricsFederationOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for metricsFederation: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RegisterPeerNode registers peer node

Register a peer node for bidirectional communication
*/
func (a *Client) RegisterPeerNode(params *RegisterPeerNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RegisterPeerNodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRegisterPeerNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "registerPeerNode",
		Method:             "POST",
		PathPattern:        "/node/register-peer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RegisterPeerNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RegisterPeerNodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for registerPeerNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RemoveConnectedPeer removes a connected peer

Removes a peer from the connected peers list
*/
func (a *Client) RemoveConnectedPeer(params *RemoveConnectedPeerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveConnectedPeerOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRemoveConnectedPeerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "removeConnectedPeer",
		Method:             "DELETE",
		PathPattern:        "/node/connected-peers/{node_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RemoveConnectedPeerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RemoveConnectedPeerOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for removeConnectedPeer: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SyncExternalNodes syncs external nodes from remote peer

Calls the remote peer's external-nodes endpoint and stores results locally
*/
func (a *Client) SyncExternalNodes(params *SyncExternalNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SyncExternalNodesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewSyncExternalNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "syncExternalNodes",
		Method:             "POST",
		PathPattern:        "/node/sync-external-nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SyncExternalNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*SyncExternalNodesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for syncExternalNodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
