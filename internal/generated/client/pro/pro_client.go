// Code generated by go-swagger; DO NOT EDIT.

package pro

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new pro API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new pro API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new pro API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for pro API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	AcceptSharedNetwork(params *AcceptSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptSharedNetworkOK, error)

	DeleteSharedNetwork(params *DeleteSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteSharedNetworkNoContent, error)

	GetKeysSharedWithMe(params *GetKeysSharedWithMeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetKeysSharedWithMeOK, error)

	GetSharedChaincode(params *GetSharedChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSharedChaincodeOK, error)

	GetSharedNetwork(params *GetSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSharedNetworkOK, error)

	ListSharedChaincodes(params *ListSharedChaincodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListSharedChaincodesOK, error)

	ListSharedNetworks(params *ListSharedNetworksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListSharedNetworksOK, error)

	ReceiveChaincodeShare(params *ReceiveChaincodeShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveChaincodeShareOK, error)

	ReceiveConfigUpdateShare(params *ReceiveConfigUpdateShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveConfigUpdateShareOK, error)

	ReceiveKey(params *ReceiveKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveKeyOK, error)

	ReceiveKeyShare(params *ReceiveKeyShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveKeyShareOK, error)

	ReceiveNetworkShare(params *ReceiveNetworkShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveNetworkShareOK, error)

	RejectSharedNetwork(params *RejectSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RejectSharedNetworkOK, error)

	ShareBesuNetwork(params *ShareBesuNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareBesuNetworkCreated, error)

	ShareChaincode(params *ShareChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareChaincodeCreated, error)

	ShareConfigProposal(params *ShareConfigProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareConfigProposalCreated, error)

	ShareKey(params *ShareKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareKeyCreated, error)

	ShareNetwork(params *ShareNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareNetworkCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AcceptSharedNetwork accepts a shared network

Accept a shared network and import it locally
*/
func (a *Client) AcceptSharedNetwork(params *AcceptSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AcceptSharedNetworkOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewAcceptSharedNetworkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "acceptSharedNetwork",
		Method:             "POST",
		PathPattern:        "/pro/shared-networks/{shareId}/accept",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AcceptSharedNetworkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*AcceptSharedNetworkOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for acceptSharedNetwork: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteSharedNetwork deletes a shared network

Delete (revoke) a shared network by shareId
*/
func (a *Client) DeleteSharedNetwork(params *DeleteSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteSharedNetworkNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteSharedNetworkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteSharedNetwork",
		Method:             "DELETE",
		PathPattern:        "/pro/shared-networks/{shareId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteSharedNetworkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeleteSharedNetworkNoContent)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteSharedNetwork: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetKeysSharedWithMe gets keys shared with the current user node

Retrieve all cryptographic keys that have been shared with the current user/node
*/
func (a *Client) GetKeysSharedWithMe(params *GetKeysSharedWithMeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetKeysSharedWithMeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetKeysSharedWithMeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getKeysSharedWithMe",
		Method:             "GET",
		PathPattern:        "/pro/keys/shared-with-me",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetKeysSharedWithMeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetKeysSharedWithMeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getKeysSharedWithMe: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetSharedChaincode gets shared chaincode definition

Get details of a specific shared chaincode definition
*/
func (a *Client) GetSharedChaincode(params *GetSharedChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSharedChaincodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetSharedChaincodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getSharedChaincode",
		Method:             "GET",
		PathPattern:        "/pro/shared-chaincodes/{chaincodeId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSharedChaincodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetSharedChaincodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSharedChaincode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetSharedNetwork gets shared network

Get a shared network by networkId
*/
func (a *Client) GetSharedNetwork(params *GetSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetSharedNetworkOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetSharedNetworkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getSharedNetwork",
		Method:             "GET",
		PathPattern:        "/pro/shared-networks/{networkId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetSharedNetworkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetSharedNetworkOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getSharedNetwork: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListSharedChaincodes lists shared chaincode definitions

List all chaincode definitions shared with us
*/
func (a *Client) ListSharedChaincodes(params *ListSharedChaincodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListSharedChaincodesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListSharedChaincodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listSharedChaincodes",
		Method:             "GET",
		PathPattern:        "/pro/shared-chaincodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListSharedChaincodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListSharedChaincodesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listSharedChaincodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListSharedNetworks lists shared networks

List all networks shared with us (both Fabric and Besu)
*/
func (a *Client) ListSharedNetworks(params *ListSharedNetworksParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListSharedNetworksOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListSharedNetworksParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listSharedNetworks",
		Method:             "GET",
		PathPattern:        "/pro/shared-networks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListSharedNetworksReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListSharedNetworksOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listSharedNetworks: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReceiveChaincodeShare receives a shared chaincode definition pro only

Receive a shared chaincode definition from another node
*/
func (a *Client) ReceiveChaincodeShare(params *ReceiveChaincodeShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveChaincodeShareOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewReceiveChaincodeShareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "receiveChaincodeShare",
		Method:             "POST",
		PathPattern:        "/pro/receive/chaincode",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReceiveChaincodeShareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ReceiveChaincodeShareOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for receiveChaincodeShare: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReceiveConfigUpdateShare receives a shared config update proposal pro only

Receive a shared config update proposal from another node
*/
func (a *Client) ReceiveConfigUpdateShare(params *ReceiveConfigUpdateShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveConfigUpdateShareOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewReceiveConfigUpdateShareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "receiveConfigUpdateShare",
		Method:             "POST",
		PathPattern:        "/pro/receive/config-update",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReceiveConfigUpdateShareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ReceiveConfigUpdateShareOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for receiveConfigUpdateShare: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReceiveKey receives a shared key

Process a received key share and store it in the local key management system
*/
func (a *Client) ReceiveKey(params *ReceiveKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveKeyOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewReceiveKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "receiveKey",
		Method:             "POST",
		PathPattern:        "/pro/key/receive",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReceiveKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ReceiveKeyOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for receiveKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReceiveKeyShare receives a shared key pro only

Receive a shared cryptographic key from another node
*/
func (a *Client) ReceiveKeyShare(params *ReceiveKeyShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveKeyShareOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewReceiveKeyShareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "receiveKeyShare",
		Method:             "POST",
		PathPattern:        "/pro/receive/key",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReceiveKeyShareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ReceiveKeyShareOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for receiveKeyShare: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReceiveNetworkShare receives a shared network pro only

Receive a shared network from another node
*/
func (a *Client) ReceiveNetworkShare(params *ReceiveNetworkShareParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReceiveNetworkShareOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewReceiveNetworkShareParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "receiveNetworkShare",
		Method:             "POST",
		PathPattern:        "/pro/receive/network",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReceiveNetworkShareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ReceiveNetworkShareOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for receiveNetworkShare: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RejectSharedNetwork rejects a shared network

Reject a shared network
*/
func (a *Client) RejectSharedNetwork(params *RejectSharedNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RejectSharedNetworkOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRejectSharedNetworkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "rejectSharedNetwork",
		Method:             "POST",
		PathPattern:        "/pro/shared-networks/{shareId}/reject",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RejectSharedNetworkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RejectSharedNetworkOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for rejectSharedNetwork: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ShareBesuNetwork shares a besu network pro only

Share a Besu network (genesis block, config, etc) with specific peers.
*/
func (a *Client) ShareBesuNetwork(params *ShareBesuNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareBesuNetworkCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewShareBesuNetworkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shareBesuNetwork",
		Method:             "POST",
		PathPattern:        "/pro/sharing/besu-network",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShareBesuNetworkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ShareBesuNetworkCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for shareBesuNetwork: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ShareChaincode shares a chaincode definition pro only

Share a chaincode definition (sequence, version, docker image, etc) with specific peers.
*/
func (a *Client) ShareChaincode(params *ShareChaincodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareChaincodeCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewShareChaincodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shareChaincode",
		Method:             "POST",
		PathPattern:        "/pro/sharing/chaincode",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShareChaincodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ShareChaincodeCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for shareChaincode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ShareConfigProposal shares a config update proposal pro only

Share a config update proposal (channel name, config update bytes, etc) with specific peers.
*/
func (a *Client) ShareConfigProposal(params *ShareConfigProposalParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareConfigProposalCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewShareConfigProposalParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shareConfigProposal",
		Method:             "POST",
		PathPattern:        "/pro/sharing/config-proposal",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShareConfigProposalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ShareConfigProposalCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for shareConfigProposal: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ShareKey shares a key with a peer

Share a cryptographic key with a specific peer connection
*/
func (a *Client) ShareKey(params *ShareKeyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareKeyCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewShareKeyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shareKey",
		Method:             "POST",
		PathPattern:        "/pro/sharing/key",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShareKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ShareKeyCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for shareKey: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ShareNetwork shares a network pro only

Share a network (genesis block, etc) with specific peers.
*/
func (a *Client) ShareNetwork(params *ShareNetworkParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ShareNetworkCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewShareNetworkParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "shareNetwork",
		Method:             "POST",
		PathPattern:        "/pro/sharing/network",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ShareNetworkReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ShareNetworkCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for shareNetwork: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
