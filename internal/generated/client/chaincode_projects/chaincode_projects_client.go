// Code generated by go-swagger; DO NOT EDIT.

package chaincode_projects

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new chaincode projects API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new chaincode projects API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new chaincode projects API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for chaincode projects API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptApplicationZip sets the Accept header to "application/zip".
func WithAcceptApplicationZip(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/zip"}
}

// WithAcceptTextEventStream sets the Accept header to "text/event-stream".
func WithAcceptTextEventStream(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/event-stream"}
}

// WithAcceptTextPlain sets the Accept header to "text/plain".
func WithAcceptTextPlain(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/plain"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	CreateProject(params *CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateProjectCreated, error)

	DeleteFile(params *DeleteFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteFileOK, error)

	DeleteProject(params *DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteProjectOK, error)

	DownloadProject(params *DownloadProjectParams, authInfo runtime.ClientAuthInfoWriter, writer io.Writer, opts ...ClientOption) (*DownloadProjectOK, error)

	GetChaincodeProjectMetadata(params *GetChaincodeProjectMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeProjectMetadataOK, error)

	GetProject(params *GetProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectOK, error)

	GetProjectCommitDetail(params *GetProjectCommitDetailParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectCommitDetailOK, error)

	GetProjectCommits(params *GetProjectCommitsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectCommitsOK, error)

	GetProjectFileAtCommit(params *GetProjectFileAtCommitParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectFileAtCommitOK, error)

	GetProjectFileDiff(params *GetProjectFileDiffParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectFileDiffOK, error)

	GetProjectLogs(params *GetProjectLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectLogsOK, error)

	InvokeChaincodeTransaction(params *InvokeChaincodeTransactionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvokeChaincodeTransactionOK, error)

	ListFiles(params *ListFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFilesOK, error)

	ListFilesEntries(params *ListFilesEntriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFilesEntriesOK, error)

	ListProjects(params *ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProjectsOK, error)

	QueryChaincodeTransaction(params *QueryChaincodeTransactionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QueryChaincodeTransactionOK, error)

	ReadFile(params *ReadFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReadFileOK, error)

	StartProjectServer(params *StartProjectServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartProjectServerOK, error)

	StopProjectServer(params *StopProjectServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopProjectServerOK, error)

	StreamProjectLogs(params *StreamProjectLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StreamProjectLogsOK, error)

	UpdateProjectEndorsementPolicy(params *UpdateProjectEndorsementPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProjectEndorsementPolicyOK, error)

	WriteFile(params *WriteFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WriteFileCreated, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
CreateProject creates a project

Create a new project, scaffold its directory, and store it in the DB
*/
func (a *Client) CreateProject(params *CreateProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateProjectCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createProject",
		Method:             "POST",
		PathPattern:        "/chaincode-projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CreateProjectCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteFile deletes a file

Delete a file in a project
*/
func (a *Client) DeleteFile(params *DeleteFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteFileOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteFile",
		Method:             "DELETE",
		PathPattern:        "/projects/{projectId}/files/delete",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeleteFileOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteProject deletes a project

Delete a project and its associated files from the system
*/
func (a *Client) DeleteProject(params *DeleteProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteProjectOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteProject",
		Method:             "DELETE",
		PathPattern:        "/chaincode-projects/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeleteProjectOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DownloadProject downloads a project as a zip file

Download a project and its associated files as a zip file, excluding common folders like node_modules, .vscode, etc.
*/
func (a *Client) DownloadProject(params *DownloadProjectParams, authInfo runtime.ClientAuthInfoWriter, writer io.Writer, opts ...ClientOption) (*DownloadProjectOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDownloadProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "downloadProject",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/download",
		ProducesMediaTypes: []string{"application/zip"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DownloadProjectReader{formats: a.formats, writer: writer},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DownloadProjectOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for downloadProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetChaincodeProjectMetadata gets project metadata

Retrieves metadata for the specified chaincode project
*/
func (a *Client) GetChaincodeProjectMetadata(params *GetChaincodeProjectMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetChaincodeProjectMetadataOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetChaincodeProjectMetadataParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getChaincodeProjectMetadata",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/metadata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetChaincodeProjectMetadataReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetChaincodeProjectMetadataOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getChaincodeProjectMetadata: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProject gets a project by ID

Get details of a project by its ID
*/
func (a *Client) GetProject(params *GetProjectParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getProject",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetProjectOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProject: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProjectCommitDetail gets commit details

Get details for a single commit, including file changes
*/
func (a *Client) GetProjectCommitDetail(params *GetProjectCommitDetailParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectCommitDetailOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectCommitDetailParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getProjectCommitDetail",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/commits/{commitHash}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectCommitDetailReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetProjectCommitDetailOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProjectCommitDetail: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProjectCommits lists project commits with file changes

Get a paginated list of commits for a project, including added/removed/modified files
*/
func (a *Client) GetProjectCommits(params *GetProjectCommitsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectCommitsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectCommitsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getProjectCommits",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/commits",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectCommitsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetProjectCommitsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProjectCommits: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProjectFileAtCommit gets file contents at a specific commit

Get the contents of a file at a specific commit hash
*/
func (a *Client) GetProjectFileAtCommit(params *GetProjectFileAtCommitParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectFileAtCommitOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectFileAtCommitParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getProjectFileAtCommit",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/file_at_commit",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectFileAtCommitReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetProjectFileAtCommitOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProjectFileAtCommit: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProjectFileDiff gets file diff between two commits

Get the diff of a file between two commits
*/
func (a *Client) GetProjectFileDiff(params *GetProjectFileDiffParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectFileDiffOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectFileDiffParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getProjectFileDiff",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/diff",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectFileDiffReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetProjectFileDiffOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProjectFileDiff: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetProjectLogs gets logs for a project server

Stream or return the logs for the project's running container
*/
func (a *Client) GetProjectLogs(params *GetProjectLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetProjectLogsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetProjectLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getProjectLogs",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/logs",
		ProducesMediaTypes: []string{"text/plain"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetProjectLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetProjectLogsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getProjectLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
InvokeChaincodeTransaction invokes a chaincode transaction

Invokes a transaction on the specified chaincode project
*/
func (a *Client) InvokeChaincodeTransaction(params *InvokeChaincodeTransactionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*InvokeChaincodeTransactionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewInvokeChaincodeTransactionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "invokeChaincodeTransaction",
		Method:             "POST",
		PathPattern:        "/chaincode-projects/{id}/invoke",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &InvokeChaincodeTransactionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*InvokeChaincodeTransactionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for invokeChaincodeTransaction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListFiles lists files

List files in a given project and directory
*/
func (a *Client) ListFiles(params *ListFilesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFilesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListFilesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listFiles",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/files/list",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListFilesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListFilesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listFiles: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListFilesEntries lists full project directory tree

List the full directory tree for a project, excluding large/ignored folders (e.g., node_modules, .git)
*/
func (a *Client) ListFilesEntries(params *ListFilesEntriesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListFilesEntriesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListFilesEntriesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listFilesEntries",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/files/entries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListFilesEntriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListFilesEntriesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listFilesEntries: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListProjects lists all projects

Get a list of all projects
*/
func (a *Client) ListProjects(params *ListProjectsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListProjectsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListProjectsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listProjects",
		Method:             "GET",
		PathPattern:        "/chaincode-projects",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListProjectsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListProjectsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listProjects: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
QueryChaincodeTransaction queries a chaincode transaction

Queries the state of the specified chaincode project
*/
func (a *Client) QueryChaincodeTransaction(params *QueryChaincodeTransactionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*QueryChaincodeTransactionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewQueryChaincodeTransactionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "queryChaincodeTransaction",
		Method:             "POST",
		PathPattern:        "/chaincode-projects/{id}/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &QueryChaincodeTransactionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*QueryChaincodeTransactionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for queryChaincodeTransaction: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReadFile reads file contents

Get the contents of a file in a project
*/
func (a *Client) ReadFile(params *ReadFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReadFileOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewReadFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "readFile",
		Method:             "GET",
		PathPattern:        "/projects/{projectId}/files/read",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReadFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ReadFileOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for readFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StartProjectServer starts the server for a project

Start the server process for a given project using its boilerplate
*/
func (a *Client) StartProjectServer(params *StartProjectServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartProjectServerOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStartProjectServerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "startProjectServer",
		Method:             "POST",
		PathPattern:        "/chaincode-projects/{id}/start",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StartProjectServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StartProjectServerOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for startProjectServer: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopProjectServer stops the server for a project

Stop the server process for a given project
*/
func (a *Client) StopProjectServer(params *StopProjectServerParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopProjectServerOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopProjectServerParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "stopProjectServer",
		Method:             "POST",
		PathPattern:        "/chaincode-projects/{id}/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopProjectServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopProjectServerOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for stopProjectServer: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StreamProjectLogs streams real time logs for a project server

Stream logs for the project's running container using SSE
*/
func (a *Client) StreamProjectLogs(params *StreamProjectLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StreamProjectLogsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStreamProjectLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "streamProjectLogs",
		Method:             "GET",
		PathPattern:        "/chaincode-projects/{id}/logs/stream",
		ProducesMediaTypes: []string{"text/event-stream"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StreamProjectLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StreamProjectLogsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for streamProjectLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateProjectEndorsementPolicy updates a project s endorsement policy

Update the endorsement policy of an existing project
*/
func (a *Client) UpdateProjectEndorsementPolicy(params *UpdateProjectEndorsementPolicyParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateProjectEndorsementPolicyOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateProjectEndorsementPolicyParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateProjectEndorsementPolicy",
		Method:             "PUT",
		PathPattern:        "/chaincode-projects/{id}/endorsement-policy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateProjectEndorsementPolicyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*UpdateProjectEndorsementPolicyOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateProjectEndorsementPolicy: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
WriteFile writes file contents

Write or modify the contents of a file in a project
*/
func (a *Client) WriteFile(params *WriteFileParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*WriteFileCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewWriteFileParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "writeFile",
		Method:             "POST",
		PathPattern:        "/projects/{projectId}/files/write",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &WriteFileReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*WriteFileCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for writeFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
