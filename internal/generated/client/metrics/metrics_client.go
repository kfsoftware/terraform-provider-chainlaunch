// Code generated by go-swagger; DO NOT EDIT.

package metrics

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new metrics API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new metrics API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new metrics API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for metrics API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptTextEventStream sets the Accept header to "text/event-stream".
func WithAcceptTextEventStream(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/event-stream"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	AddGenericJob(params *AddGenericJobParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddGenericJobOK, error)

	CheckPortAvailability(params *CheckPortAvailabilityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CheckPortAvailabilityOK, error)

	ConnectionCustomQuery(params *ConnectionCustomQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ConnectionCustomQueryOK, error)

	ConnectionCustomQueryFiltered(params *ConnectionCustomQueryFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ConnectionCustomQueryFilteredOK, error)

	CustomQuery(params *CustomQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CustomQueryOK, error)

	CustomQueryFiltered(params *CustomQueryFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CustomQueryFilteredOK, error)

	DeployPrometheus(params *DeployPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeployPrometheusOK, error)

	GetConnectionLabelValues(params *GetConnectionLabelValuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionLabelValuesOK, error)

	GetConnectionMetrics(params *GetConnectionMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionMetricsOK, error)

	GetConnectionMetricsFiltered(params *GetConnectionMetricsFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionMetricsFilteredOK, error)

	GetConnectionMetricsRange(params *GetConnectionMetricsRangeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionMetricsRangeOK, error)

	GetDefaults(params *GetDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDefaultsOK, error)

	GetJobLabelValues(params *GetJobLabelValuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobLabelValuesOK, error)

	GetJobMetrics(params *GetJobMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobMetricsOK, error)

	GetJobMetricsFiltered(params *GetJobMetricsFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobMetricsFilteredOK, error)

	GetJobMetricsRange(params *GetJobMetricsRangeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobMetricsRangeOK, error)

	GetLabelValues(params *GetLabelValuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLabelValuesOK, error)

	GetMetadata(params *GetMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMetadataOK, error)

	GetNodeMetrics(params *GetNodeMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeMetricsOK, error)

	GetNodeMetricsFiltered(params *GetNodeMetricsFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeMetricsFilteredOK, error)

	GetNodeMetricsRange(params *GetNodeMetricsRangeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeMetricsRangeOK, error)

	GetStatus(params *GetStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetStatusOK, error)

	GetTargets(params *GetTargetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetTargetsOK, error)

	GlobalFilteredQuery(params *GlobalFilteredQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GlobalFilteredQueryOK, error)

	JobCustomQuery(params *JobCustomQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobCustomQueryOK, error)

	JobCustomQueryFiltered(params *JobCustomQueryFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobCustomQueryFilteredOK, error)

	ListJobs(params *ListJobsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListJobsOK, error)

	RefreshPrometheus(params *RefreshPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RefreshPrometheusOK, error)

	ReloadConfiguration(params *ReloadConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReloadConfigurationOK, error)

	RemoveGenericJob(params *RemoveGenericJobParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveGenericJobOK, error)

	SearchMetrics(params *SearchMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SearchMetricsOK, error)

	StartPrometheus(params *StartPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartPrometheusOK, error)

	StopPrometheus(params *StopPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopPrometheusOK, error)

	TailMetricsLogs(params *TailMetricsLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TailMetricsLogsOK, error)

	UndeployPrometheus(params *UndeployPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UndeployPrometheusOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
AddGenericJob adds a new generic job target

Adds a new generic job target to Prometheus configuration
*/
func (a *Client) AddGenericJob(params *AddGenericJobParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*AddGenericJobOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewAddGenericJobParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "addGenericJob",
		Method:             "POST",
		PathPattern:        "/metrics/job/add",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddGenericJobReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*AddGenericJobOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for addGenericJob: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CheckPortAvailability checks port availability

Checks if a specific port is available for Prometheus deployment
*/
func (a *Client) CheckPortAvailability(params *CheckPortAvailabilityParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CheckPortAvailabilityOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCheckPortAvailabilityParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "checkPortAvailability",
		Method:             "GET",
		PathPattern:        "/metrics/port/{port}/check",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CheckPortAvailabilityReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CheckPortAvailabilityOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for checkPortAvailability: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ConnectionCustomQuery executes custom prometheus query for a connection

Execute a custom Prometheus query with optional time range for a specific connection
*/
func (a *Client) ConnectionCustomQuery(params *ConnectionCustomQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ConnectionCustomQueryOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewConnectionCustomQueryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "connectionCustomQuery",
		Method:             "POST",
		PathPattern:        "/metrics/connection/{id}/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ConnectionCustomQueryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ConnectionCustomQueryOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for connectionCustomQuery: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ConnectionCustomQueryFiltered executes custom filtered prometheus query for a connection

Execute a custom Prometheus query with dynamic filtering for a specific connection
*/
func (a *Client) ConnectionCustomQueryFiltered(params *ConnectionCustomQueryFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ConnectionCustomQueryFilteredOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewConnectionCustomQueryFilteredParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "connectionCustomQueryFiltered",
		Method:             "POST",
		PathPattern:        "/metrics/connection/{id}/query/filtered",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ConnectionCustomQueryFilteredReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ConnectionCustomQueryFilteredOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for connectionCustomQueryFiltered: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CustomQuery executes custom prometheus query

Execute a custom Prometheus query with optional time range
*/
func (a *Client) CustomQuery(params *CustomQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CustomQueryOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCustomQueryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "customQuery",
		Method:             "POST",
		PathPattern:        "/metrics/node/{id}/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CustomQueryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CustomQueryOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for customQuery: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CustomQueryFiltered executes custom filtered prometheus query for a node

Execute a custom Prometheus query with dynamic filtering for a specific node
*/
func (a *Client) CustomQueryFiltered(params *CustomQueryFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CustomQueryFilteredOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCustomQueryFilteredParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "customQueryFiltered",
		Method:             "POST",
		PathPattern:        "/metrics/node/{id}/query/filtered",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CustomQueryFilteredReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CustomQueryFilteredOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for customQueryFiltered: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeployPrometheus deploys a new prometheus instance

Deploys a new Prometheus instance with the specified configuration
*/
func (a *Client) DeployPrometheus(params *DeployPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeployPrometheusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeployPrometheusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deployPrometheus",
		Method:             "POST",
		PathPattern:        "/metrics/deploy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeployPrometheusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeployPrometheusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deployPrometheus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetConnectionLabelValues gets label values for a specific connection

Retrieves all values for a specific label, optionally filtered by metric matches and connection ID
*/
func (a *Client) GetConnectionLabelValues(params *GetConnectionLabelValuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionLabelValuesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetConnectionLabelValuesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getConnectionLabelValues",
		Method:             "GET",
		PathPattern:        "/metrics/connection/{id}/label/{label}/values",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConnectionLabelValuesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetConnectionLabelValuesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getConnectionLabelValues: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetConnectionMetrics gets all metrics for a connection ID

Retrieves all metrics for a specific connection ID using federated metrics query
*/
func (a *Client) GetConnectionMetrics(params *GetConnectionMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionMetricsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetConnectionMetricsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getConnectionMetrics",
		Method:             "GET",
		PathPattern:        "/metrics/connection/{id}/metrics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConnectionMetricsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetConnectionMetricsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getConnectionMetrics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetConnectionMetricsFiltered gets filtered metrics for a specific connection

Retrieves metrics for a specific connection with dynamic filtering support
*/
func (a *Client) GetConnectionMetricsFiltered(params *GetConnectionMetricsFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionMetricsFilteredOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetConnectionMetricsFilteredParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getConnectionMetricsFiltered",
		Method:             "GET",
		PathPattern:        "/metrics/connection/{id}/filtered",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConnectionMetricsFilteredReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetConnectionMetricsFilteredOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getConnectionMetricsFiltered: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetConnectionMetricsRange gets metrics for a specific connection with time range

Retrieves metrics for a specific connection within a specified time range
*/
func (a *Client) GetConnectionMetricsRange(params *GetConnectionMetricsRangeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetConnectionMetricsRangeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetConnectionMetricsRangeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getConnectionMetricsRange",
		Method:             "GET",
		PathPattern:        "/metrics/connection/{id}/range",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConnectionMetricsRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetConnectionMetricsRangeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getConnectionMetricsRange: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetDefaults gets default values for prometheus deployment

Returns default configuration values including available ports for Prometheus deployment
*/
func (a *Client) GetDefaults(params *GetDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetDefaultsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetDefaultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getDefaults",
		Method:             "GET",
		PathPattern:        "/metrics/defaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDefaultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetDefaultsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getDefaults: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetJobLabelValues gets label values for a specific job

Retrieves all values for a specific label, optionally filtered by metric matches and job name
*/
func (a *Client) GetJobLabelValues(params *GetJobLabelValuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobLabelValuesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetJobLabelValuesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getJobLabelValues",
		Method:             "GET",
		PathPattern:        "/metrics/job/{jobName}/label/{label}/values",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetJobLabelValuesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetJobLabelValuesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getJobLabelValues: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetJobMetrics gets metrics for a specific job

Retrieves metrics for a specific job by name and optional PromQL query
*/
func (a *Client) GetJobMetrics(params *GetJobMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobMetricsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetJobMetricsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getJobMetrics",
		Method:             "GET",
		PathPattern:        "/metrics/job/{jobName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetJobMetricsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetJobMetricsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getJobMetrics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetJobMetricsFiltered gets filtered metrics for a specific job

Retrieves metrics for a specific job with dynamic filtering support
*/
func (a *Client) GetJobMetricsFiltered(params *GetJobMetricsFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobMetricsFilteredOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetJobMetricsFilteredParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getJobMetricsFiltered",
		Method:             "GET",
		PathPattern:        "/metrics/job/{jobName}/filtered",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetJobMetricsFilteredReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetJobMetricsFilteredOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getJobMetricsFiltered: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetJobMetricsRange gets metrics for a specific job with time range

Retrieves metrics for a specific job within a specified time range
*/
func (a *Client) GetJobMetricsRange(params *GetJobMetricsRangeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetJobMetricsRangeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetJobMetricsRangeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getJobMetricsRange",
		Method:             "GET",
		PathPattern:        "/metrics/job/{jobName}/range",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetJobMetricsRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetJobMetricsRangeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getJobMetricsRange: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetLabelValues gets label values for a specific label

Retrieves all values for a specific label, optionally filtered by metric matches and node ID
*/
func (a *Client) GetLabelValues(params *GetLabelValuesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetLabelValuesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetLabelValuesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getLabelValues",
		Method:             "GET",
		PathPattern:        "/metrics/node/{id}/label/{label}/values",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetLabelValuesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetLabelValuesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getLabelValues: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetMetadata gets prometheus metadata

Retrieves metadata about all available metrics in Prometheus
*/
func (a *Client) GetMetadata(params *GetMetadataParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetMetadataOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetMetadataParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getMetadata",
		Method:             "GET",
		PathPattern:        "/metrics/metadata",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMetadataReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetMetadataOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getMetadata: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeMetrics gets metrics for a specific node

Retrieves metrics for a specific node by ID and optional PromQL query
*/
func (a *Client) GetNodeMetrics(params *GetNodeMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeMetricsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeMetricsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeMetrics",
		Method:             "GET",
		PathPattern:        "/metrics/node/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeMetricsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeMetricsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeMetrics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeMetricsFiltered gets filtered metrics for a specific node

Retrieves metrics for a specific node with dynamic filtering support
*/
func (a *Client) GetNodeMetricsFiltered(params *GetNodeMetricsFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeMetricsFilteredOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeMetricsFilteredParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeMetricsFiltered",
		Method:             "GET",
		PathPattern:        "/metrics/node/{id}/filtered",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeMetricsFilteredReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeMetricsFilteredOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeMetricsFiltered: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeMetricsRange gets metrics for a specific node with time range

Retrieves metrics for a specific node within a specified time range
*/
func (a *Client) GetNodeMetricsRange(params *GetNodeMetricsRangeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeMetricsRangeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeMetricsRangeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeMetricsRange",
		Method:             "GET",
		PathPattern:        "/metrics/node/{id}/range",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeMetricsRangeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeMetricsRangeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeMetricsRange: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetStatus gets prometheus status

Returns the current status of the Prometheus instance including version, port, and configuration
*/
func (a *Client) GetStatus(params *GetStatusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetStatusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getStatus",
		Method:             "GET",
		PathPattern:        "/metrics/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetStatusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetStatusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getStatus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetTargets gets prometheus targets

Retrieves the list of targets and their status from Prometheus
*/
func (a *Client) GetTargets(params *GetTargetsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetTargetsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetTargetsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getTargets",
		Method:             "GET",
		PathPattern:        "/metrics/targets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetTargetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetTargetsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getTargets: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GlobalFilteredQuery executes global filtered prometheus query

Execute a Prometheus query with dynamic filtering across all available metrics
*/
func (a *Client) GlobalFilteredQuery(params *GlobalFilteredQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GlobalFilteredQueryOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGlobalFilteredQueryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "globalFilteredQuery",
		Method:             "POST",
		PathPattern:        "/metrics/query/filtered",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GlobalFilteredQueryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GlobalFilteredQueryOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for globalFilteredQuery: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
JobCustomQuery executes custom prometheus query for a job

Execute a custom Prometheus query with optional time range for a specific job
*/
func (a *Client) JobCustomQuery(params *JobCustomQueryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobCustomQueryOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewJobCustomQueryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "jobCustomQuery",
		Method:             "POST",
		PathPattern:        "/metrics/job/{jobName}/query",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JobCustomQueryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*JobCustomQueryOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for jobCustomQuery: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
JobCustomQueryFiltered executes custom filtered prometheus query for a job

Execute a custom Prometheus query with dynamic filtering for a specific job
*/
func (a *Client) JobCustomQueryFiltered(params *JobCustomQueryFilteredParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*JobCustomQueryFilteredOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewJobCustomQueryFilteredParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "jobCustomQueryFiltered",
		Method:             "POST",
		PathPattern:        "/metrics/job/{jobName}/query/filtered",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JobCustomQueryFilteredReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*JobCustomQueryFilteredOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for jobCustomQueryFiltered: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListJobs lists all jobs

Lists all available jobs in Prometheus with their targets and status
*/
func (a *Client) ListJobs(params *ListJobsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListJobsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListJobsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listJobs",
		Method:             "GET",
		PathPattern:        "/metrics/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListJobsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListJobsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listJobs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RefreshPrometheus refreshes prometheus deployment

Refreshes the Prometheus deployment with new configuration parameters
*/
func (a *Client) RefreshPrometheus(params *RefreshPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RefreshPrometheusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRefreshPrometheusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "refreshPrometheus",
		Method:             "POST",
		PathPattern:        "/metrics/refresh",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RefreshPrometheusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RefreshPrometheusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for refreshPrometheus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ReloadConfiguration reloads prometheus configuration

Triggers a reload of the Prometheus configuration to pick up any changes
*/
func (a *Client) ReloadConfiguration(params *ReloadConfigurationParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ReloadConfigurationOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewReloadConfigurationParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "reloadConfiguration",
		Method:             "POST",
		PathPattern:        "/metrics/reload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReloadConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ReloadConfigurationOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for reloadConfiguration: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RemoveGenericJob removes a generic job

Removes a generic job from Prometheus configuration
*/
func (a *Client) RemoveGenericJob(params *RemoveGenericJobParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RemoveGenericJobOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRemoveGenericJobParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "removeGenericJob",
		Method:             "DELETE",
		PathPattern:        "/metrics/job/{jobName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RemoveGenericJobReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RemoveGenericJobOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for removeGenericJob: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
SearchMetrics searches metrics with dynamic filtering

Search for metrics using various filtering criteria and search terms
*/
func (a *Client) SearchMetrics(params *SearchMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*SearchMetricsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewSearchMetricsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "searchMetrics",
		Method:             "GET",
		PathPattern:        "/metrics/search",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SearchMetricsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*SearchMetricsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for searchMetrics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StartPrometheus starts prometheus instance

Starts the Prometheus instance if it's currently stopped
*/
func (a *Client) StartPrometheus(params *StartPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartPrometheusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStartPrometheusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "startPrometheus",
		Method:             "POST",
		PathPattern:        "/metrics/start",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StartPrometheusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StartPrometheusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for startPrometheus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopPrometheus stops prometheus instance

Stops the Prometheus instance if it's currently running
*/
func (a *Client) StopPrometheus(params *StopPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopPrometheusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopPrometheusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "stopPrometheus",
		Method:             "POST",
		PathPattern:        "/metrics/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopPrometheusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopPrometheusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for stopPrometheus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TailMetricsLogs tails prometheus logs

Streams Prometheus logs with optional tail and follow functionality
*/
func (a *Client) TailMetricsLogs(params *TailMetricsLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TailMetricsLogsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewTailMetricsLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "tailMetricsLogs",
		Method:             "GET",
		PathPattern:        "/metrics/logs",
		ProducesMediaTypes: []string{"text/event-stream"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TailMetricsLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*TailMetricsLogsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for tailMetricsLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UndeployPrometheus undeploys prometheus instance

Stops and removes the Prometheus instance
*/
func (a *Client) UndeployPrometheus(params *UndeployPrometheusParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UndeployPrometheusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUndeployPrometheusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "undeployPrometheus",
		Method:             "POST",
		PathPattern:        "/metrics/undeploy",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UndeployPrometheusReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*UndeployPrometheusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for undeployPrometheus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
