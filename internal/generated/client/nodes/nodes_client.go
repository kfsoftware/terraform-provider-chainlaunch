// Code generated by go-swagger; DO NOT EDIT.

package nodes

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
)

// New creates a new nodes API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

// New creates a new nodes API client with basic auth credentials.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - user: user for basic authentication header.
// - password: password for basic authentication header.
func NewClientWithBasicAuth(host, basePath, scheme, user, password string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BasicAuth(user, password)
	return &Client{transport: transport, formats: strfmt.Default}
}

// New creates a new nodes API client with a bearer token for authentication.
// It takes the following parameters:
// - host: http host (github.com).
// - basePath: any base path for the API client ("/v1", "/v3").
// - scheme: http scheme ("http", "https").
// - bearerToken: bearer token for Bearer authentication header.
func NewClientWithBearerToken(host, basePath, scheme, bearerToken string) ClientService {
	transport := httptransport.New(host, basePath, []string{scheme})
	transport.DefaultAuthentication = httptransport.BearerToken(bearerToken)
	return &Client{transport: transport, formats: strfmt.Default}
}

/*
Client for nodes API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption may be used to customize the behavior of Client methods.
type ClientOption func(*runtime.ClientOperation)

// This client is generated with a few options you might find useful for your swagger spec.
//
// Feel free to add you own set of options.

// WithAccept allows the client to force the Accept header
// to negotiate a specific Producer from the server.
//
// You may use this option to set arbitrary extensions to your MIME media type.
func WithAccept(mime string) ClientOption {
	return func(r *runtime.ClientOperation) {
		r.ProducesMediaTypes = []string{mime}
	}
}

// WithAcceptApplicationJSON sets the Accept header to "application/json".
func WithAcceptApplicationJSON(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"application/json"}
}

// WithAcceptTextEventStream sets the Accept header to "text/event-stream".
func WithAcceptTextEventStream(r *runtime.ClientOperation) {
	r.ProducesMediaTypes = []string{"text/event-stream"}
}

// ClientService is the interface for Client methods
type ClientService interface {
	GetNodesIDRPCAccounts(params *GetNodesIDRPCAccountsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCAccountsOK, error)

	GetNodesIDRPCBalance(params *GetNodesIDRPCBalanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBalanceOK, error)

	GetNodesIDRPCBlockByHash(params *GetNodesIDRPCBlockByHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockByHashOK, error)

	GetNodesIDRPCBlockByNumber(params *GetNodesIDRPCBlockByNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockByNumberOK, error)

	GetNodesIDRPCBlockNumber(params *GetNodesIDRPCBlockNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockNumberOK, error)

	GetNodesIDRPCBlockTransactionCountByHash(params *GetNodesIDRPCBlockTransactionCountByHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockTransactionCountByHashOK, error)

	GetNodesIDRPCBlockTransactionCountByNumber(params *GetNodesIDRPCBlockTransactionCountByNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockTransactionCountByNumberOK, error)

	GetNodesIDRPCChainID(params *GetNodesIDRPCChainIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCChainIDOK, error)

	GetNodesIDRPCCode(params *GetNodesIDRPCCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCCodeOK, error)

	GetNodesIDRPCDecodeInput(params *GetNodesIDRPCDecodeInputParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCDecodeInputOK, error)

	GetNodesIDRPCFeeHistory(params *GetNodesIDRPCFeeHistoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCFeeHistoryOK, error)

	GetNodesIDRPCPendingTransactions(params *GetNodesIDRPCPendingTransactionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCPendingTransactionsOK, error)

	GetNodesIDRPCProtocolVersion(params *GetNodesIDRPCProtocolVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCProtocolVersionOK, error)

	GetNodesIDRPCQbftPendingVotes(params *GetNodesIDRPCQbftPendingVotesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftPendingVotesOK, error)

	GetNodesIDRPCQbftRequestTimeout(params *GetNodesIDRPCQbftRequestTimeoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftRequestTimeoutOK, error)

	GetNodesIDRPCQbftSignerMetrics(params *GetNodesIDRPCQbftSignerMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftSignerMetricsOK, error)

	GetNodesIDRPCQbftValidatorsByBlockHash(params *GetNodesIDRPCQbftValidatorsByBlockHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftValidatorsByBlockHashOK, error)

	GetNodesIDRPCQbftValidatorsByBlockNumber(params *GetNodesIDRPCQbftValidatorsByBlockNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftValidatorsByBlockNumberOK, error)

	GetNodesIDRPCStorage(params *GetNodesIDRPCStorageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCStorageOK, error)

	GetNodesIDRPCSyncing(params *GetNodesIDRPCSyncingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCSyncingOK, error)

	GetNodesIDRPCTransactionByBlockHashAndIndex(params *GetNodesIDRPCTransactionByBlockHashAndIndexParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionByBlockHashAndIndexOK, error)

	GetNodesIDRPCTransactionByBlockNumberAndIndex(params *GetNodesIDRPCTransactionByBlockNumberAndIndexParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionByBlockNumberAndIndexOK, error)

	GetNodesIDRPCTransactionByHash(params *GetNodesIDRPCTransactionByHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionByHashOK, error)

	GetNodesIDRPCTransactionCount(params *GetNodesIDRPCTransactionCountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionCountOK, error)

	GetNodesIDRPCTransactionReceipt(params *GetNodesIDRPCTransactionReceiptParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionReceiptOK, error)

	GetNodesReadinessBesu(params *GetNodesReadinessBesuParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesReadinessBesuOK, error)

	PostNodesIDRPCLogs(params *PostNodesIDRPCLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PostNodesIDRPCLogsOK, error)

	PostNodesIDRPCQbftDiscardValidatorVote(params *PostNodesIDRPCQbftDiscardValidatorVoteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PostNodesIDRPCQbftDiscardValidatorVoteOK, error)

	PostNodesIDRPCQbftProposeValidatorVote(params *PostNodesIDRPCQbftProposeValidatorVoteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PostNodesIDRPCQbftProposeValidatorVoteOK, error)

	CreateNode(params *CreateNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateNodeCreated, error)

	DeleteNode(params *DeleteNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteNodeNoContent, error)

	GetAvailableDeploymentModes(params *GetAvailableDeploymentModesParams, opts ...ClientOption) (*GetAvailableDeploymentModesOK, error)

	GetBesuNodeDefaults(params *GetBesuNodeDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBesuNodeDefaultsOK, error)

	GetFabricNodesDefaults(params *GetFabricNodesDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFabricNodesDefaultsOK, error)

	GetFabricOrdererDefaults(params *GetFabricOrdererDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFabricOrdererDefaultsOK, error)

	GetFabricPeerDefaults(params *GetFabricPeerDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFabricPeerDefaultsOK, error)

	GetNode(params *GetNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeOK, error)

	GetNodeBySlug(params *GetNodeBySlugParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeBySlugOK, error)

	GetNodeChaincodes(params *GetNodeChaincodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeChaincodesOK, error)

	GetNodeChannelHeight(params *GetNodeChannelHeightParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeChannelHeightOK, error)

	GetNodeChannels(params *GetNodeChannelsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeChannelsOK, error)

	GetNodeEvents(params *GetNodeEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeEventsOK, error)

	GetNodeHealthHistory(params *GetNodeHealthHistoryParams, opts ...ClientOption) (*GetNodeHealthHistoryOK, error)

	GetNodeHealthStatus(params *GetNodeHealthStatusParams, opts ...ClientOption) (*GetNodeHealthStatusOK, error)

	ListNodes(params *ListNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNodesOK, error)

	ListNodesByPlatform(params *ListNodesByPlatformParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNodesByPlatformOK, error)

	RenewNodeCertificates(params *RenewNodeCertificatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RenewNodeCertificatesOK, error)

	RestartNode(params *RestartNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestartNodeOK, error)

	StartNode(params *StartNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartNodeOK, error)

	StopNode(params *StopNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopNodeOK, error)

	TailNodesLogs(params *TailNodesLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TailNodesLogsOK, error)

	UpdateNode(params *UpdateNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNodeOK, error)

	VerifyBesuVersion(params *VerifyBesuVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VerifyBesuVersionOK, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
GetNodesIDRPCAccounts gets accounts managed by the besu node

Lists accounts managed by the node
*/
func (a *Client) GetNodesIDRPCAccounts(params *GetNodesIDRPCAccountsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCAccountsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCAccountsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCAccounts",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/accounts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCAccountsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCAccountsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCAccounts: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCBalance gets balance of an address

Gets balance of an address in Wei
*/
func (a *Client) GetNodesIDRPCBalance(params *GetNodesIDRPCBalanceParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBalanceOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCBalanceParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCBalance",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/balance",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCBalanceReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCBalanceOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCBalance: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCBlockByHash gets block by hash

Gets block details by hash
*/
func (a *Client) GetNodesIDRPCBlockByHash(params *GetNodesIDRPCBlockByHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockByHashOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCBlockByHashParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCBlockByHash",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/block-by-hash",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCBlockByHashReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCBlockByHashOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCBlockByHash: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCBlockByNumber gets block by number

Gets block by number or tag
*/
func (a *Client) GetNodesIDRPCBlockByNumber(params *GetNodesIDRPCBlockByNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockByNumberOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCBlockByNumberParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCBlockByNumber",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/block-by-number",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCBlockByNumberReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCBlockByNumberOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCBlockByNumber: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCBlockNumber gets latest block number

Gets the latest block number
*/
func (a *Client) GetNodesIDRPCBlockNumber(params *GetNodesIDRPCBlockNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockNumberOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCBlockNumberParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCBlockNumber",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/block-number",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCBlockNumberReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCBlockNumberOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCBlockNumber: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCBlockTransactionCountByHash gets transaction count in block by hash

Gets transaction count in a block by hash
*/
func (a *Client) GetNodesIDRPCBlockTransactionCountByHash(params *GetNodesIDRPCBlockTransactionCountByHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockTransactionCountByHashOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCBlockTransactionCountByHashParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCBlockTransactionCountByHash",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/block-transaction-count-by-hash",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCBlockTransactionCountByHashReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCBlockTransactionCountByHashOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCBlockTransactionCountByHash: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCBlockTransactionCountByNumber gets transaction count in block by number

Gets transaction count by block number
*/
func (a *Client) GetNodesIDRPCBlockTransactionCountByNumber(params *GetNodesIDRPCBlockTransactionCountByNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCBlockTransactionCountByNumberOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCBlockTransactionCountByNumberParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCBlockTransactionCountByNumber",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/block-transaction-count-by-number",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCBlockTransactionCountByNumberReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCBlockTransactionCountByNumberOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCBlockTransactionCountByNumber: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCChainID gets chain ID

Gets the chain ID
*/
func (a *Client) GetNodesIDRPCChainID(params *GetNodesIDRPCChainIDParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCChainIDOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCChainIDParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCChainID",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/chain-id",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCChainIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCChainIDOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCChainID: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCCode gets bytecode at an address

Gets bytecode at an address (e.g., contract code)
*/
func (a *Client) GetNodesIDRPCCode(params *GetNodesIDRPCCodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCCodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCCodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCCode",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/code",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCCodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCCode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCDecodeInput decodes transaction input data

Decodes transaction input data using function signatures from 4byte.directory and extracts parameter values
*/
func (a *Client) GetNodesIDRPCDecodeInput(params *GetNodesIDRPCDecodeInputParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCDecodeInputOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCDecodeInputParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCDecodeInput",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/decode-input",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCDecodeInputReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCDecodeInputOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCDecodeInput: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCFeeHistory gets fee history

Gets historical gas fees
*/
func (a *Client) GetNodesIDRPCFeeHistory(params *GetNodesIDRPCFeeHistoryParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCFeeHistoryOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCFeeHistoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCFeeHistory",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/fee-history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCFeeHistoryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCFeeHistoryOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCFeeHistory: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCPendingTransactions gets pending transactions

Gets pending transactions in the mempool
*/
func (a *Client) GetNodesIDRPCPendingTransactions(params *GetNodesIDRPCPendingTransactionsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCPendingTransactionsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCPendingTransactionsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCPendingTransactions",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/pending-transactions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCPendingTransactionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCPendingTransactionsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCPendingTransactions: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCProtocolVersion gets protocol version

Gets Ethereum protocol version
*/
func (a *Client) GetNodesIDRPCProtocolVersion(params *GetNodesIDRPCProtocolVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCProtocolVersionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCProtocolVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCProtocolVersion",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/protocol-version",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCProtocolVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCProtocolVersionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCProtocolVersion: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCQbftPendingVotes gets q b f t pending votes

Retrieves a map of pending validator proposals where keys are validator addresses and values are boolean (true indicates pending vote)
*/
func (a *Client) GetNodesIDRPCQbftPendingVotes(params *GetNodesIDRPCQbftPendingVotesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftPendingVotesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCQbftPendingVotesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCQbftPendingVotes",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/qbft-pending-votes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCQbftPendingVotesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCQbftPendingVotesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCQbftPendingVotes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCQbftRequestTimeout gets q b f t request timeout

Gets QBFT request timeout in seconds
*/
func (a *Client) GetNodesIDRPCQbftRequestTimeout(params *GetNodesIDRPCQbftRequestTimeoutParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftRequestTimeoutOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCQbftRequestTimeoutParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCQbftRequestTimeout",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/qbft-request-timeout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCQbftRequestTimeoutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCQbftRequestTimeoutOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCQbftRequestTimeout: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCQbftSignerMetrics gets q b f t signer metrics

Gets QBFT signer metrics
*/
func (a *Client) GetNodesIDRPCQbftSignerMetrics(params *GetNodesIDRPCQbftSignerMetricsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftSignerMetricsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCQbftSignerMetricsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCQbftSignerMetrics",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/qbft-signer-metrics",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCQbftSignerMetricsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCQbftSignerMetricsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCQbftSignerMetrics: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCQbftValidatorsByBlockHash gets q b f t validators by block hash

Retrieves the list of validators for a specific block by its hash
*/
func (a *Client) GetNodesIDRPCQbftValidatorsByBlockHash(params *GetNodesIDRPCQbftValidatorsByBlockHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftValidatorsByBlockHashOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCQbftValidatorsByBlockHashParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCQbftValidatorsByBlockHash",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/qbft-validators-by-block-hash",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCQbftValidatorsByBlockHashReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCQbftValidatorsByBlockHashOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCQbftValidatorsByBlockHash: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCQbftValidatorsByBlockNumber gets q b f t validators by block number

Retrieves the list of validators for a specific block by its number
*/
func (a *Client) GetNodesIDRPCQbftValidatorsByBlockNumber(params *GetNodesIDRPCQbftValidatorsByBlockNumberParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCQbftValidatorsByBlockNumberOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCQbftValidatorsByBlockNumberParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCQbftValidatorsByBlockNumber",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/qbft-validators-by-block-number",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCQbftValidatorsByBlockNumberReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCQbftValidatorsByBlockNumberOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCQbftValidatorsByBlockNumber: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCStorage gets storage value at a position

Gets storage value at a position for an address
*/
func (a *Client) GetNodesIDRPCStorage(params *GetNodesIDRPCStorageParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCStorageOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCStorageParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCStorage",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/storage",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCStorageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCStorageOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCStorage: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCSyncing gets sync status

Gets sync status
*/
func (a *Client) GetNodesIDRPCSyncing(params *GetNodesIDRPCSyncingParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCSyncingOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCSyncingParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCSyncing",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/syncing",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCSyncingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCSyncingOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCSyncing: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCTransactionByBlockHashAndIndex gets transaction by block hash and index

Gets transaction by block hash and index
*/
func (a *Client) GetNodesIDRPCTransactionByBlockHashAndIndex(params *GetNodesIDRPCTransactionByBlockHashAndIndexParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionByBlockHashAndIndexOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCTransactionByBlockHashAndIndexParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCTransactionByBlockHashAndIndex",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/transaction-by-block-hash-and-index",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCTransactionByBlockHashAndIndexReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCTransactionByBlockHashAndIndexOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCTransactionByBlockHashAndIndex: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCTransactionByBlockNumberAndIndex gets transaction by block number and index

Gets transaction by block number and index
*/
func (a *Client) GetNodesIDRPCTransactionByBlockNumberAndIndex(params *GetNodesIDRPCTransactionByBlockNumberAndIndexParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionByBlockNumberAndIndexOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCTransactionByBlockNumberAndIndexParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCTransactionByBlockNumberAndIndex",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/transaction-by-block-number-and-index",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCTransactionByBlockNumberAndIndexReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCTransactionByBlockNumberAndIndexOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCTransactionByBlockNumberAndIndex: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCTransactionByHash gets transaction by hash

Gets transaction details by hash
*/
func (a *Client) GetNodesIDRPCTransactionByHash(params *GetNodesIDRPCTransactionByHashParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionByHashOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCTransactionByHashParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCTransactionByHash",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/transaction-by-hash",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCTransactionByHashReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCTransactionByHashOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCTransactionByHash: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCTransactionCount gets transaction count for an address

Gets nonce (tx count) for an address
*/
func (a *Client) GetNodesIDRPCTransactionCount(params *GetNodesIDRPCTransactionCountParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionCountOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCTransactionCountParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCTransactionCount",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/transaction-count",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCTransactionCountReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCTransactionCountOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCTransactionCount: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesIDRPCTransactionReceipt gets transaction receipt

Gets receipt for a transaction
*/
func (a *Client) GetNodesIDRPCTransactionReceipt(params *GetNodesIDRPCTransactionReceiptParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesIDRPCTransactionReceiptOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesIDRPCTransactionReceiptParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesIDRPCTransactionReceipt",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/rpc/transaction-receipt",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesIDRPCTransactionReceiptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesIDRPCTransactionReceiptOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesIDRPCTransactionReceipt: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodesReadinessBesu checks besu readiness

Check if Java and Besu are installed and ready for deployment
*/
func (a *Client) GetNodesReadinessBesu(params *GetNodesReadinessBesuParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodesReadinessBesuOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodesReadinessBesuParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetNodesReadinessBesu",
		Method:             "GET",
		PathPattern:        "/nodes/readiness/besu",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodesReadinessBesuReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodesReadinessBesuOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetNodesReadinessBesu: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PostNodesIDRPCLogs gets event logs

Gets event logs based on filter criteria
*/
func (a *Client) PostNodesIDRPCLogs(params *PostNodesIDRPCLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PostNodesIDRPCLogsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPostNodesIDRPCLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PostNodesIDRPCLogs",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/rpc/logs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostNodesIDRPCLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*PostNodesIDRPCLogsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PostNodesIDRPCLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PostNodesIDRPCQbftDiscardValidatorVote discards q b f t validator vote

Discards a pending vote for a validator proposal
*/
func (a *Client) PostNodesIDRPCQbftDiscardValidatorVote(params *PostNodesIDRPCQbftDiscardValidatorVoteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PostNodesIDRPCQbftDiscardValidatorVoteOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPostNodesIDRPCQbftDiscardValidatorVoteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PostNodesIDRPCQbftDiscardValidatorVote",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/rpc/qbft-discard-validator-vote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostNodesIDRPCQbftDiscardValidatorVoteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*PostNodesIDRPCQbftDiscardValidatorVoteOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PostNodesIDRPCQbftDiscardValidatorVote: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
PostNodesIDRPCQbftProposeValidatorVote proposes q b f t validator vote

Proposes a vote to add (true) or remove (false) a validator
*/
func (a *Client) PostNodesIDRPCQbftProposeValidatorVote(params *PostNodesIDRPCQbftProposeValidatorVoteParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*PostNodesIDRPCQbftProposeValidatorVoteOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewPostNodesIDRPCQbftProposeValidatorVoteParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "PostNodesIDRPCQbftProposeValidatorVote",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/rpc/qbft-propose-validator-vote",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostNodesIDRPCQbftProposeValidatorVoteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*PostNodesIDRPCQbftProposeValidatorVoteOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PostNodesIDRPCQbftProposeValidatorVote: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
CreateNode creates a new node

Create a new node with the specified configuration
*/
func (a *Client) CreateNode(params *CreateNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*CreateNodeCreated, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewCreateNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "createNode",
		Method:             "POST",
		PathPattern:        "/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*CreateNodeCreated)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for createNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
DeleteNode deletes a node

Delete a node by ID
*/
func (a *Client) DeleteNode(params *DeleteNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*DeleteNodeNoContent, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewDeleteNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "deleteNode",
		Method:             "DELETE",
		PathPattern:        "/nodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*DeleteNodeNoContent)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetAvailableDeploymentModes gets available deployment modes

Returns the list of deployment modes available in the current environment
*/
func (a *Client) GetAvailableDeploymentModes(params *GetAvailableDeploymentModesParams, opts ...ClientOption) (*GetAvailableDeploymentModesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetAvailableDeploymentModesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getAvailableDeploymentModes",
		Method:             "GET",
		PathPattern:        "/nodes/deployment-modes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAvailableDeploymentModesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetAvailableDeploymentModesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getAvailableDeploymentModes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetBesuNodeDefaults gets besu node defaults

Get default configuration for Besu nodes
*/
func (a *Client) GetBesuNodeDefaults(params *GetBesuNodeDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetBesuNodeDefaultsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetBesuNodeDefaultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getBesuNodeDefaults",
		Method:             "GET",
		PathPattern:        "/nodes/defaults/besu-node",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetBesuNodeDefaultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetBesuNodeDefaultsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getBesuNodeDefaults: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetFabricNodesDefaults gets fabric nodes defaults

Get default configuration for Fabric nodes
*/
func (a *Client) GetFabricNodesDefaults(params *GetFabricNodesDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFabricNodesDefaultsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetFabricNodesDefaultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getFabricNodesDefaults",
		Method:             "GET",
		PathPattern:        "/nodes/defaults/fabric",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetFabricNodesDefaultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetFabricNodesDefaultsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getFabricNodesDefaults: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetFabricOrdererDefaults gets fabric orderer defaults

Get default configuration for Fabric orderer nodes
*/
func (a *Client) GetFabricOrdererDefaults(params *GetFabricOrdererDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFabricOrdererDefaultsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetFabricOrdererDefaultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getFabricOrdererDefaults",
		Method:             "GET",
		PathPattern:        "/nodes/defaults/fabric-orderer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetFabricOrdererDefaultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetFabricOrdererDefaultsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getFabricOrdererDefaults: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetFabricPeerDefaults gets fabric peer defaults

Get default configuration for Fabric peer nodes
*/
func (a *Client) GetFabricPeerDefaults(params *GetFabricPeerDefaultsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetFabricPeerDefaultsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetFabricPeerDefaultsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getFabricPeerDefaults",
		Method:             "GET",
		PathPattern:        "/nodes/defaults/fabric-peer",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetFabricPeerDefaultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetFabricPeerDefaultsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getFabricPeerDefaults: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNode gets a node

Get a node by ID
*/
func (a *Client) GetNode(params *GetNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNode",
		Method:             "GET",
		PathPattern:        "/nodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeBySlug gets a node by slug

Get a node by its unique slug identifier
*/
func (a *Client) GetNodeBySlug(params *GetNodeBySlugParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeBySlugOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeBySlugParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeBySlug",
		Method:             "GET",
		PathPattern:        "/nodes/slug/{slug}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeBySlugReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeBySlugOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeBySlug: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeChaincodes gets node chaincodes

Get installed chaincodes for a Fabric node
*/
func (a *Client) GetNodeChaincodes(params *GetNodeChaincodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeChaincodesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeChaincodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeChaincodes",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/channels/{channelID}/chaincodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeChaincodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeChaincodesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeChaincodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeChannelHeight gets node channel height

Get the block height for a specific channel on a Fabric node
*/
func (a *Client) GetNodeChannelHeight(params *GetNodeChannelHeightParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeChannelHeightOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeChannelHeightParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeChannelHeight",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/channels/{channelID}/height",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeChannelHeightReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeChannelHeightOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeChannelHeight: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeChannels gets node channels

Get channels for a Fabric node
*/
func (a *Client) GetNodeChannels(params *GetNodeChannelsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeChannelsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeChannelsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeChannels",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/channels",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeChannelsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeChannelsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeChannels: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeEvents gets node events

Get events for a specific node
*/
func (a *Client) GetNodeEvents(params *GetNodeEventsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*GetNodeEventsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeEventsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeEvents",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeEventsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeEvents: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeHealthHistory gets health check history for a node

Retrieve health check history for a specific node within a time range
*/
func (a *Client) GetNodeHealthHistory(params *GetNodeHealthHistoryParams, opts ...ClientOption) (*GetNodeHealthHistoryOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeHealthHistoryParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeHealthHistory",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/health/history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeHealthHistoryReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeHealthHistoryOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeHealthHistory: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
GetNodeHealthStatus gets current health status of a node

Retrieve the latest health check result for a specific node
*/
func (a *Client) GetNodeHealthStatus(params *GetNodeHealthStatusParams, opts ...ClientOption) (*GetNodeHealthStatusOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewGetNodeHealthStatusParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "getNodeHealthStatus",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/health",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetNodeHealthStatusReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*GetNodeHealthStatusOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for getNodeHealthStatus: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListNodes lists all nodes

Get a paginated list of nodes with optional filtering by name, slug, status, platform, type, network, or organization
*/
func (a *Client) ListNodes(params *ListNodesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNodesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListNodesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listNodes",
		Method:             "GET",
		PathPattern:        "/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListNodesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListNodesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listNodes: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
ListNodesByPlatform lists nodes by platform

Get a paginated list of nodes filtered by blockchain platform
*/
func (a *Client) ListNodesByPlatform(params *ListNodesByPlatformParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*ListNodesByPlatformOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewListNodesByPlatformParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "listNodesByPlatform",
		Method:             "GET",
		PathPattern:        "/nodes/platform/{platform}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListNodesByPlatformReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*ListNodesByPlatformOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for listNodesByPlatform: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RenewNodeCertificates renews node certificates

Renew certificates for a node
*/
func (a *Client) RenewNodeCertificates(params *RenewNodeCertificatesParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RenewNodeCertificatesOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRenewNodeCertificatesParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "renewNodeCertificates",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/certificates/renew",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RenewNodeCertificatesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RenewNodeCertificatesOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for renewNodeCertificates: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
RestartNode restarts a node

Restart a node by ID (stops and starts the node)
*/
func (a *Client) RestartNode(params *RestartNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*RestartNodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewRestartNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "restartNode",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/restart",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RestartNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*RestartNodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for restartNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StartNode starts a node

Start a node by ID
*/
func (a *Client) StartNode(params *StartNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StartNodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStartNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "startNode",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/start",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StartNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StartNodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for startNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
StopNode stops a node

Stop a node by ID
*/
func (a *Client) StopNode(params *StopNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*StopNodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewStopNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "stopNode",
		Method:             "POST",
		PathPattern:        "/nodes/{id}/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*StopNodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for stopNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
TailNodesLogs tails node logs

Stream logs from a specific node
*/
func (a *Client) TailNodesLogs(params *TailNodesLogsParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*TailNodesLogsOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewTailNodesLogsParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "tailNodesLogs",
		Method:             "GET",
		PathPattern:        "/nodes/{id}/logs",
		ProducesMediaTypes: []string{"text/event-stream"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TailNodesLogsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*TailNodesLogsOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for tailNodesLogs: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
UpdateNode updates a node

Update a node configuration
*/
func (a *Client) UpdateNode(params *UpdateNodeParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*UpdateNodeOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewUpdateNodeParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "updateNode",
		Method:             "PUT",
		PathPattern:        "/nodes/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateNodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*UpdateNodeOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for updateNode: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
VerifyBesuVersion verifies besu binary version

Verifies that a Besu binary can be executed for the specified version, downloading it if necessary
*/
func (a *Client) VerifyBesuVersion(params *VerifyBesuVersionParams, authInfo runtime.ClientAuthInfoWriter, opts ...ClientOption) (*VerifyBesuVersionOK, error) {
	// NOTE: parameters are not validated before sending
	if params == nil {
		params = NewVerifyBesuVersionParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "verifyBesuVersion",
		Method:             "POST",
		PathPattern:        "/nodes/verify/besu",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &VerifyBesuVersionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}
	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}

	// only one success response has to be checked
	success, ok := result.(*VerifyBesuVersionOK)
	if ok {
		return success, nil
	}

	// unexpected success response.

	// no default response is defined.
	//
	// safeguard: normally, in the absence of a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for verifyBesuVersion: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
